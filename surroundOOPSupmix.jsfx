// based on vocalrediso.jsfx
// uses some code from https://github.com/Nbickford/REAPERDenoiser

desc: decode OOPS at -pi/6 and 2/3*pi with better seperation
//tags: processing stereo surround phase fft
//author: Michael Pannekoek

import cookdsp.jsfx-inc

slider1:0<-60,20,0.1>Output volume (dB)
slider2:0<0,1,1{Yes, No}>Remove C and RL/RR from L and R
slider3:0<-5,5,0.001>strength at Low Freq
slider4:0<-5,5,0.001>strength at High Freq
slider7:1<0.05,2,0.05>Rear width (multiplier)
slider8:90<1,180,0.1>Low Freq phase width (Degrees)
slider9:90<1,180,0.1>High Freq phase width (Degrees)
slider10:10<1,100,1>Attenuate if different volume

in_pin:left input
in_pin:right input
out_pin:L output
out_pin:R output
out_pin:C output
out_pin:LFE output
out_pin:RL output
out_pin:RR output


@slider
// let amp be slider1 converted from dB to linear
amp = 10^(slider1/20);

// assign slider3 and slider4 to lowstrength and highstrength respectively
lowStrength = slider3;
highstrength = slider4;

// assign slider8 and slider9 to phaseWlow and phaseWhigh,
// converting from degrees to radians, respectively.
phaseWlow = slider8*$pi/180;
phaseWhigh = slider9*$pi/180;

// let rwmult be the mulplicative inverse of slider 7
rwmult = 1 / slider7;

// fill strengthBuffer and phaseWBuffer with SIZE elements
bandIndex = 0;
loop(SIZE,
	// let frac be equal to the ratio of bandIndex to SIZEMINUSONE
	frac = bandIndex/SIZEMINUSONE;
	frac = max(0, min(1, frac));
	// fraction of progress through range [lowBin, highBin)
	strength = lowStrength* (1 - frac) + highStrength * frac;
	strengthBuffer[bandIndex] = 10^strength;
	// precaculate strength (actual value should be positive, so it makes
	// sense to take the power of ten, but only after the
	// linear mapping over the spectrum is done.
	phaseW = phaseWlow * (1 - frac) + phaseWhigh * frac;
	phaseWBuffer[bandIndex] = phaseW;
	// precalculate phase width

	windowBufferIn[bandIndex] = sin($pi*(bandIndex+1/2)/SIZE);
	windowBufferOut[bandIndex] = sin($pi*(bandIndex+1/2)/SIZE);

	bandIndex += 1;
	// next index
);



@init
// angles for RL and RR
RLtheta = -$pi/6;
RRtheta = 2*$pi/3;

// calculate the cosine and sin of both RLtheta and RRtheta
cosRLtheta = cos(RLtheta);
sinRLtheta = sin(RLtheta);
cosRRtheta = cos(RRtheta);
sinRRtheta = sin(RRtheta);

// square the above values
cosRLthetaSQ = sqr(cosRLtheta);
sinRLthetaSQ = sqr(sinRLtheta);
cosRRthetaSQ = sqr(cosRRtheta);
sinRRthetaSQ = sqr(sinRRtheta);

// compute the abs of sin of 2 times RLtheta and RRtheta respectively
sin2RLThetaABS = abs(sin(2*RLTheta));
sin2RRThetaABS = abs(sin(2*RRTheta));

cosRLthetaminuspiforths = cos(RLtheta-$pi/4);
cosRLthetapluspiforths = cos(RLtheta+$pi/4);
sinRLthetaminuspiforths = sin(RLtheta-$pi/4);
sinRLthetapluspiforths = sin(RLtheta+$pi/4);
cosRRthetaminuspiforths = cos(RRtheta-$pi/4);
cosRRthetapluspiforths = cos(RRtheta+$pi/4);
sinRRthetaminuspiforths = sin(RRtheta-$pi/4);
sinRRthetapluspiforths = sin(RRtheta+$pi/4);

// init variables
// buffers
// FFT - fft window size (will be constant)
SIZE = 8192;
SIZEMINUSONE = SIZE-1;
DOUBLESIZE = SIZE*2;
HALFSIZE = SIZE/2;
HALFSIZEINV = 2/SIZE;
HALFSIZEMINUSONE = HALFSIZE-1;

// let there be two frames of silence
// to mute the first inital buffers
silence = 2;

// set each buffer to the offsef from the last to make it easier to move them around
// fft has real and complex values thus is twice as large
// bufferFFTIL, bufferFFTIR, bufferFFTOL, bufferFFTOR, bufferFFTOC, bufferFFTORL, bufferFFORR are all DOUBLESIZE in length (vecause they hold complex numbers)
bufferFFTIL = 0;
bufferFFTIR = bufferFFTIL+DOUBLESIZE;
bufferFFTOL = bufferFFTIR+DOUBLESIZE;
bufferFFTOR = bufferFFTOL+DOUBLESIZE;
bufferFFTOC = bufferFFTOR+DOUBLESIZE;
bufferFFTORL = bufferFFTOC+DOUBLESIZE;
bufferFFTORR = bufferFFTORL+DOUBLESIZE;
// bufferI1L, bufferI2L, bufferI1R, bufferI2R, bufferO1L, bufferO2L, bufferO1R, bufferO2R, bufferO1C, bufferO2C, bufferO1RL, bufferO2RL, bufferO1RR, bufferO2RR are all SIZE lin length
bufferI1L = bufferFFTORR+DOUBLESIZE;
bufferI2L = bufferI1L+SIZE;
bufferI1R = bufferI2L+SIZE;
bufferI2R = bufferI1R+SIZE;
bufferO1L = bufferI2R+SIZE;
bufferO2L = bufferO1L+SIZE;
bufferO1R = bufferO2L+SIZE;
bufferO2R = bufferO1R+SIZE;
bufferO1C = bufferO2R+SIZE;
bufferO2C = bufferO1C+SIZE;
bufferO1RL = bufferO2C+SIZE;
bufferO2RL = bufferO1RL+SIZE;
bufferO1RR = bufferO2RL+SIZE;
bufferO2RR = bufferO1RR+SIZE;
// strengthBuffer, phaseWBuffer, windowBufferIn, windowBufferOut are all SIZE in length
strengthBuffer = bufferO2RR+SIZE;
phaseWBuffer = strengthBuffer+SIZE;
windowBufferIn = phaseWBuffer+SIZE;
windowBufferOut = windowBufferIn+SIZE;
// now freembuf the memory past the end of windowBufferOut
freembuf(windowBufferOut+SIZE);

// samplesCollected tracks the position in the last of the two tiles, starting from 0
samplesCollected = 0;
// ranges from 0 to (SIZE/2)-1

// tell reaper what delay this plugin will introduce,
// so that it can be compensated for
// delay is one full buffer (length SIZE)
pdc_delay = SIZE;
// the channels from 0 inclusive to 8 (not inclusive) are delayed
pdc_bot_ch = 0; pdc_top_ch = 8;

// Init Cookdsp filters
// (a buthp for CBHP1 with argument 70, and butlp for LFELP1 with argument 70)
CBHP1.buthp(70);
LFEBLP1.butlp(70);


@sample
// store raw samples for later storing in input buffer
firstL = spl0;
firstR = spl1;

// that's a lowercase L in spl, not the number 1.
// spl0 corresponds to L, spl1 corresponds to R.

// read input from buffers (or just read from spl if no buffering)

sampleLeft = firstL;
sampleRight = firstR;

// find positions in tile 1 and 2
tilePos1 = samplesCollected + HALFSIZE;
tilePos2 = samplesCollected;

// apply the selected envelope while writing the sample into the tile buffer
// See https://en.wikipedia.org/wiki/Window_function
windowTileIn1 = windowBufferIn[tilePos1];
windowTileIn2 = windowBufferIn[tilePos2];
windowTileOut1 = windowBufferOut[tilePos1];
windowTileOut2 = windowBufferOut[tilePos2];
// windowTile2 has a relationship to the other window tile, so
// it is epressed in this way for accuracy and speed


// find scaling factor to undo scaling caused by windows
outScale = windowTileIn1 * windowTileOut1 + windowTileIn2 * windowTileOut2;

// output samples
outLPart1 = bufferO1L[tilePos1] * windowTileOut1;
outLPart2 = bufferO2L[tilePos2] * windowTileOut2;
outL = (outLPart1 + outLPart2);

outRPart1 = bufferO1R[tilePos1] * windowTileOut1;
outRPart2 = bufferO2R[tilePos2] * windowTileOut2;
outR = (outRPart1 + outRPart2);

outCPart1 = bufferO1C[tilePos1] * windowTileOut1;
outCPart2 = bufferO2C[tilePos2] * windowTileOut2;
outC = (outCPart1 + outCPart2);
outCwet = CBHP1.buthp_do(outC);
outLFE = LFEBLP1.butlp_do(outC);

outRLPart1 = bufferO1RL[tilePos1] * windowTileOut1;
outRLPart2 = bufferO2RL[tilePos2] * windowTileOut2;
outRL = (outRLPart1 + outRLPart2);

outRRPart1 = bufferO1RR[tilePos1] * windowTileOut1;
outRRPart2 = bufferO2RR[tilePos2] * windowTileOut2;
outRR = (outRRPart1 + outRRPart2);

// output audio
silence <= 0 ? (
	spl0 = amp * outL;
	spl1 = amp * outR;
	spl2 += amp * outCwet;
	spl3 += amp * outLFE;
	spl4 += amp * outRL * 1.5;
	spl5 += amp * outRR * 1.5;
	spl6 = amp * (outRL + outL) * 0.5;
	spl7 = amp * (outRR + outR) * 0.5;
) : (
	spl0 = 0;
	spl1 = 0;
	spl2 = 0;
	spl3 = 0;
	spl4 = 0;
	spl5 = 0;
	spl6 = 0;
	spl7 = 0;
);

// write to input tile buffers:
// Left + Right input buffers
bufferI1L[tilePos1] = sampleLeft * windowTileIn1;
bufferI2L[tilePos2] = sampleLeft * windowTileIn2;
bufferI1R[tilePos1] = sampleRight * windowTileIn1;
bufferI2R[tilePos2] = sampleRight * windowTileIn2;

// increment positions
samplesCollected += 1;

// once we reach the end of a tile:
samplesCollected >= HALFSIZE ?
(
	// wrap back to 0 on the tile
	samplesCollected = 0;

	// make silence go to 0
	silence > 0 ? silence -= 1;

	// fill input FFT buffers
	// Loop over each of the audio samples, from index = 0 to SIZE - 1.
	index = 0;
	loop(SIZE,
		// divide by HALFSIZE because applying the FFT and IFFT adds a factor of SIZE
		// and filtering out the negative frequencies adds a factor of 1/2
		bufferFFTIL[2 * index + 0] = bufferI1L[index] * HALFSIZEINV; // real
		bufferFFTIL[2 * index + 1] = 0.0; // imaginary
		bufferFFTIR[2 * index + 0] = bufferI1R[index] * HALFSIZEINV; // real
		bufferFFTIR[2 * index + 1] = 0.0; // imaginary
		index += 1;
		// Next index
	);
	// calculate fft in place for L
	// size specifies the number of bins
	// (one complex number for each bin)
	fft(bufferFFTIL, SIZE);
	// need to permute the frequency bins to get them in the right order
	// See https://www.reaper.fm/sdk/js/advfunc.php#js_advanced for more info.
	fft_permute(bufferFFTIL, SIZE);

	// calculate fft in place for R
	// size specifies the number of bins
	// (one complex number for each bin)
	fft(bufferFFTIR, SIZE);
	// need to permute the frequency bins to get them in the right order
	// See https://www.reaper.fm/sdk/js/advfunc.php#js_advanced for more info.
	fft_permute(bufferFFTIR, SIZE);

	//////BAND 0
	// just add together samples, phase information is meaningless
	Lreal = bufferFFTIL[0];
	Limag = bufferFFTIL[1];
	Rreal = bufferFFTIR[0];
	Rimag = bufferFFTIR[1];

	// fill output FFT buffers
	bufferFFTOL[0] = Lreal*0.5;
	bufferFFTOL[1] = Limag*0.5;
	bufferFFTOR[0] = Rreal*0.5;
	bufferFFTOR[1] = Rimag*0.5;
	bufferFFTOC[0] = (Lreal + Rreal)*0.25;
	bufferFFTOC[1] = (Limag + Rimag)*0.25;
	bufferFFTORL[0] = (Lreal*cosRLtheta + Rreal*sinRLtheta)*0.5;
	bufferFFTORL[1] = (Limag*cosRLtheta + Rimag*sinRLtheta)*0.5;
	bufferFFTORR[0] = (Lreal*cosRRtheta + Rreal*sinRRtheta)*0.5;
	bufferFFTORR[1] = (Limag*cosRRtheta + Rimag*sinRRtheta)*0.5;

	//////BANDS 1 to SIZE/2-2
	bandIndex = 1;
	loop(HALFSIZE-1,
// get strength for this band
		strength = strengthBuffer[bandIndex];

		// get phase width for this band
		phaseW = phaseWBuffer[bandIndex];
		
		// extract real and imaginary indexes from bandIndex
		bandReal = 2 * bandIndex;
		bandImag = 1 + bandReal;
		
		// get dry fft coefficeients from bufferFFTIL and bufferFFTIR
		Lreal = bufferFFTIL[bandReal];
		Limag = bufferFFTIL[bandImag];
		Rreal = bufferFFTIR[bandReal];
		Rimag = bufferFFTIR[bandImag];
		
		// find the norm squared of L and R (Ldot and Rdot)
		Ldot = sqr(Lreal) + sqr(Limag);
		Rdot = sqr(Rreal) + sqr(Rimag);
		
		// use those results to also find norm
		Lnorm = sqrt(Ldot);
		Rnorm = sqrt(Rdot);
		
		// calculate the arguments to atan2 for the difference between phases of L and R          
		xval = Lreal*Rreal+Limag*Rimag;
		yval = Limag*Rreal-Rimag*Lreal;

		//// C channel
		// find C phase (no rotation needed)
		thetaC = atan2(yval, xval);

		// caculate C weight (weightC2) given phase
		uncappedC = abs(thetaC) / phaseW;
		weightC1 = min(1, uncappedC);
		weightC2 = 1 - (weightC1 ^ strength);
		
		// calculate attenC: compare magnitudes of Lnorm and Rnorm
		attenC = (2*Lnorm*Rnorm/(Ldot+Rdot));
		// calculate weightC using attenC: raise attenC to (strength times slider10), and also multiply by weightC2
		weightC = weightC2 * attenC ^ (strength * slider10);

		// calculate and attenuate centre fft
		// should multiply by 0.5 because two things are added together
		Creal = (Lreal + Rreal) * weightC * 0.5;
		Cimag = (Limag + Rimag) * weightC * 0.5;


		//// RL
		// Find Rear phase, (twisted 180 degrees)
		thetaRear = atan2(yval, -xval);
		// calculate RL weight (weightRL2) given phase
		uncappedRL = abs(thetaRear) / phaseW * rwmult;
		weightRL1 = min(1, uncappedRL);
		weightRL2 = 1 - (weightRL1 ^ strength);

		// calculate attenRL: compare magnitudes of Lnorm and Rnorm by RLTheta
		attenRL = (sin2RLThetaABS*Lnorm*Rnorm/(sinRLthetaSQ*Ldot+cosRLthetaSQ*Rdot));
		// calculate weightRL using attenRL: raise attenRL to (strength divided by slider10), and also multiply by weightRL2
		weightRL = weightRL2 * attenRL ^ (strength * slider10);

		// calculate and attenuate RL fft
		RLreal = (Lreal*cosRLtheta + Rreal*sinRLtheta)*weightRL;
		RLimag = (Limag*cosRLtheta + Rimag*sinRLtheta)*weightRL;
		// this is RL shifted by j (90 degrees phase)

		//// RR
		
		// calculate RR weight (weightRR2) given phase
		// reuse thetaRear phase here
		uncappedRR = abs(thetaRear) / phaseW * rwmult;
		weightRR1 = min(1, uncappedRR);
		weightRR2 = 1 - (weightRR1 ^ strength);

		// calculate attenRR: compare magnitudes of Lnorm and Rnorm by RRTheta
		attenRR = (sin2RRThetaABS*Lnorm*Rnorm/(sinRRthetaSQ*Ldot+cosRRthetaSQ*Rdot));
		// calculate weightRR using attenRR: raise attenRR to (strength times slider10), and also multiply by weightRR2
		weightRR = weightRR2 * attenRR ^ (strength * slider10);

		// calculate and attenuate RR fft
		RRreal = (Lreal*cosRRtheta + Rreal*sinRRtheta)*weightRR;
		RRimag = (Limag*cosRRtheta + Rimag*sinRRtheta)*weightRR;
		// this is RR shifted by k (-90 degrees phase)

		slider2 == 0 ? (
			// remove center, RL and RR from L
			Lreal -= Creal + cosRLtheta*RLreal + cosRRtheta*RRreal;
			Limag -= Cimag + cosRLtheta*RLimag + cosRRtheta*RRimag;
			// remove center, RL and RR from R
			Rreal -= Creal + sinRLtheta*RLreal + sinRRtheta*RRreal;
			Rimag -= Cimag + sinRLtheta*RLimag + sinRRtheta*RRimag;
		);

		// fill output fft buffers
		// because all bands from SIZE/2 onwards are 0
		// the hilbert will be in the imaginary part of the inverse FFT results
		// but need to scale coefficeients by 2
		bufferFFTOL[bandReal] = Lreal;
		bufferFFTOL[bandImag] = Limag;
		bufferFFTOR[bandReal] = Rreal;
		bufferFFTOR[bandImag] = Rimag;
		bufferFFTOC[bandReal] = Creal;
		bufferFFTOC[bandImag] = Cimag;
		bufferFFTORL[bandReal] = RLreal;
		bufferFFTORL[bandImag] = RLimag;
		bufferFFTORR[bandReal] = RRreal;
		bufferFFTORR[bandImag] = RRimag;
		bandIndex += 1;
	);

	////// BAND SIZE/2
	bandIndex = HALFSIZE;
	// just add together samples, phase information is meaningless
	Lreal = bufferFFTIL[bandIndex * 2];
	Limag = bufferFFTIL[bandIndex * 2 + 1];
	Rreal = bufferFFTIR[bandIndex * 2];
	Rimag = bufferFFTIR[bandIndex * 2 + 1];

	// fill output FFT buffers
	bufferFFTOL[bandIndex * 2] = Lreal*0.5;
	bufferFFTOL[bandIndex * 2 + 1] = Limag*0.5;
	bufferFFTOR[bandIndex * 2] = Rreal*0.5;
	bufferFFTOR[bandIndex * 2 + 1] = Rimag*0.5;
	bufferFFTOC[bandIndex * 2] = (Lreal + Rreal)*0.25;
	bufferFFTOC[bandIndex * 2 + 1] = (Limag + Rimag)*0.25;
	bufferFFTORL[bandIndex * 2] = (Lreal*cosRLtheta + Rreal*sinRLtheta)*0.5;
	bufferFFTORL[bandIndex * 2 + 1] = (Limag*cosRLtheta + Rimag*sinRLtheta)*0.5;
	bufferFFTORR[bandIndex * 2] = (Lreal*cosRRtheta + Rreal*sinRRtheta)*0.5;
	bufferFFTORR[bandIndex * 2 + 1] = (Limag*cosRRtheta + Rimag*sinRRtheta)*0.5;

	// BANDS SIZE/2 to SIZE-1
	memset(bufferFFTOL+SIZE+2, 0, SIZE-2);
	memset(bufferFFTOR+SIZE+2, 0, SIZE-2);
	memset(bufferFFTOC+SIZE+2, 0, SIZE-2);
	memset(bufferFFTORL+SIZE+2, 0, SIZE-2);
	memset(bufferFFTORR+SIZE+2, 0, SIZE-2);

	// apply ifft to FFTOL
	fft_ipermute(bufferFFTOL, SIZE);
	ifft(bufferFFTOL, SIZE);

	// apply ifft to FFTOR
	fft_ipermute(bufferFFTOR, SIZE);
	ifft(bufferFFTOR, SIZE);

	// apply ifft to FFTOC
	fft_ipermute(bufferFFTOC, SIZE);
	ifft(bufferFFTOC, SIZE);

	// apply ifft to FFTORL
	fft_ipermute(bufferFFTORL, SIZE);
	ifft(bufferFFTORL, SIZE);

	// apply ifft to FFTORR
	fft_ipermute(bufferFFTORR, SIZE);
	ifft(bufferFFTORR, SIZE);

	// Copy from the complex numbers in bufferFFTO* to the bufferO1* tile:
	index = 0;
	loop(SIZE,
		// take real part
		bufferO1L[index] = bufferFFTOL[2 * index];
		bufferO1R[index] = bufferFFTOR[2 * index];
		bufferO1C[index] = bufferFFTOC[2 * index];
		// RL and RR have had hilbert applied
		// take the - 90 degree shift to compensate
		bufferO1RL[index] = -bufferFFTORL[2 * index + 1];
		bufferO1RR[index] = bufferFFTORR[2 * index + 1];
		index += 1;
	);

	// finally, swap tiles
	temp = bufferI1L;
	bufferI1L = bufferI2L;
	bufferI2L = temp;

	temp = bufferI1R;
	bufferI1R = bufferI2R;
	bufferI2R = temp;

	temp = bufferO1L;
	bufferO1L = bufferO2L;
	bufferO2L = temp;

	temp = bufferO1R;
	bufferO1R = bufferO2R;
	bufferO2R = temp;

	temp = bufferO1C;
	bufferO1C = bufferO2C;
	bufferO2C = temp;

	temp = bufferO1RL;
	bufferO1RL = bufferO2RL;
	bufferO2RL = temp;

	temp = bufferO1RR;
	bufferO1RR = bufferO2RR;
	bufferO2RR = temp;
);

// sliders are serialized automatically
// thus nothing to serialize, as nothing else makes sense to store
